#!/usr/bin/env python3
import os
import re
import sqlite3
import logging
from datetime import datetime
from supabase import create_client
from dotenv import load_dotenv

# Load environment variables and configure logging
load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("vendor_management")

# Configuration
DB_FILE = "DB/pepsources.db"
SUPABASE_URL = os.getenv("VITE_SUPABASE_URL") or os.environ.get("VITE_SUPABASE_URL")
SUPABASE_KEY = os.getenv("VITE_SUPABASE_SERVICE_KEY") or os.environ.get("VITE_SUPABASE_SERVICE_KEY")

# Column name mapping (SQLite → Supabase)
COLUMN_MAPPING = {
    'pros_cons': 'pros_cons',
    'Pros_Cons': 'pros_cons',
    'external_COA_provider': 'external_coa_provider',
    'external_coa_provider': 'external_coa_provider',
    'comission': 'comission',
    'Reimburse_Test': 'reimburse_test',
    'reimburse_test': 'reimburse_test',
    'Test_rating': 'test_rating',
    'test_rating': 'test_rating',
    'Region': 'region',
    'region': 'region'
}

def parse_price(price_str):
    """Extract numeric value from price string."""
    if not price_str or not price_str.strip():
        return None
    try:
        # Handle price ranges by taking the average
        if '–' in price_str or '-' in price_str:
            parts = re.split(r'[–-]', price_str)
            if len(parts) == 2:
                price1 = re.sub(r"[^\d\.]", "", parts[0])
                price2 = re.sub(r"[^\d\.]", "", parts[1])
                return (float(price1) + float(price2)) / 2
        
        # Normal price parsing
        value = re.sub(r"[^\d\.]", "", price_str)
        return float(value) if value else None
    except Exception as e:
        logger.warning(f"Error parsing price '{price_str}': {e}")
        return None

def parse_size(size_str):
    """Extract numeric value from size string."""
    if not size_str or not size_str.strip():
        return None
    try:
        value = re.sub(r"[^\d\.]", "", size_str)
        return float(value) if value else None
    except Exception as e:
        logger.warning(f"Error parsing size '{size_str}': {e}")
        return None

def get_supabase_schema():
    """Get Supabase schema to ensure column compatibility."""
    try:
        supabase = create_client(SUPABASE_URL, SUPABASE_KEY)
        response = supabase.table('vendordetails').select('*').limit(1).execute()
        
        if not response.data:
            logger.warning("No data in vendordetails table to determine schema")
            return set(['id', 'name', 'vendor_id', 'small_order_rating', 'large_order_rating'])
        
        sample_row = response.data[0]
        column_names = set(k.lower() for k in sample_row.keys())
        logger.info(f"Found {len(column_names)} columns in Supabase vendordetails table")
        return column_names
    
    except Exception as e:
        logger.error(f"Error fetching Supabase schema: {e}")
        return set(['id', 'name', 'vendor_id', 'small_order_rating', 'large_order_rating'])

def sync_new_vendors():
    """Add new vendors from Vendors table to VendorDetails table, using name for deduplication."""
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    try:
        # Get all existing vendors in VendorDetails by name
        cursor.execute("SELECT name FROM VendorDetails WHERE name IS NOT NULL")
        existing_vendors = {row['name'] for row in cursor.fetchall()}
        logger.info(f"Found {len(existing_vendors)} existing vendors in VendorDetails")
        
        # Find vendors not yet in VendorDetails by name
        query = """
            SELECT DISTINCT v.id, v.name FROM Vendors v
            WHERE v.name IS NOT NULL AND v.name != ''
            ORDER BY v.name
        """
        
        cursor.execute(query)
        vendor_rows = cursor.fetchall()
        logger.info(f"Found {len(vendor_rows)} total vendors in Vendors table")
        
        added_count = 0
        for vendor in vendor_rows:
            vendor_id = vendor['id']
            vendor_name = vendor['name']
            
            if vendor_name in existing_vendors:
                # Update vendor_id if needed
                cursor.execute(
                    "UPDATE VendorDetails SET vendor_id = ? WHERE name = ? AND (vendor_id IS NULL OR vendor_id != ?)",
                    (vendor_id, vendor_name, vendor_id)
                )
                if cursor.rowcount > 0:
                    logger.info(f"Updated vendor_id for existing vendor '{vendor_name}'")
                continue
            
            # Insert new vendor with name
            try:
                cursor.execute(
                    "INSERT INTO VendorDetails (name, vendor_id) VALUES (?, ?)",
                    (vendor_name, vendor_id)
                )
                added_count += 1
                logger.info(f"Added new vendor '{vendor_name}' to VendorDetails")
                existing_vendors.add(vendor_name)  # Update set to prevent duplicates
            except Exception as e:
                logger.error(f"Error adding vendor '{vendor_name}': {e}")
        
        conn.commit()
        return added_count
    
    except Exception as e:
        logger.error(f"Error syncing new vendors: {e}")
        return 0
    finally:
        conn.close()

def update_price_ratings():
    """Calculate and update price ratings for all vendors."""
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    try:
        # Get vendor rows with price and size
        cursor.execute("""
            SELECT id, name, price, size FROM Vendors 
            WHERE price IS NOT NULL AND price != '' 
            AND size IS NOT NULL AND size != ''
        """)
        rows = cursor.fetchall()
        
        # Group by vendor and compute price per mg
        vendor_groups = {}
        for row in rows:
            price = parse_price(row["price"])
            size = parse_size(row["size"])
            if not price or not size or size == 0:
                continue
                
            price_per_mg = price / size
            vendor_name = row["name"]
            vendor_groups.setdefault(vendor_name, []).append({
                "price_per_mg": price_per_mg
            })
        
        if not vendor_groups:
            logger.warning("No valid price/size data found for any vendors")
            return 0
            
        # Calculate metrics for each vendor
        vendor_metrics = {}
        for vendor, listings in vendor_groups.items():
            small_metric = min(listing["price_per_mg"] for listing in listings)
            large_metric = max(listing["price_per_mg"] for listing in listings)
            vendor_metrics[vendor] = {
                "small_metric": small_metric,
                "large_metric": large_metric
            }
        
        # Rank vendors (5 = best, 1 = worst)
        vendors_small_sorted = sorted(vendor_metrics.items(), key=lambda x: x[1]["small_metric"])
        vendors_large_sorted = sorted(vendor_metrics.items(), key=lambda x: x[1]["large_metric"])
        
        n = len(vendor_metrics)
        
        def rank_rating(index):
            if n == 1:
                return 5.0
            return 5 - (index * (4 / (n - 1)))
        
        # Assign ratings
        vendor_ratings = {}
        for idx, (vendor, _) in enumerate(vendors_small_sorted):
            vendor_ratings.setdefault(vendor, {})["small_order_rating"] = round(rank_rating(idx), 2)
        for idx, (vendor, _) in enumerate(vendors_large_sorted):
            vendor_ratings.setdefault(vendor, {})["large_order_rating"] = round(rank_rating(idx), 2)
        
        # Update ratings in database by name
        updated_count = 0
        for vendor, ratings in vendor_ratings.items():
            try:
                cursor.execute("""
                    UPDATE VendorDetails 
                    SET small_order_rating = ?, large_order_rating = ?
                    WHERE name = ?
                """, (
                    ratings["small_order_rating"], 
                    ratings["large_order_rating"], 
                    vendor
                ))
                
                if cursor.rowcount > 0:
                    updated_count += cursor.rowcount
                    logger.info(f"Updated ratings for '{vendor}': small={ratings['small_order_rating']}, large={ratings['large_order_rating']}")
                else:
                    logger.warning(f"No rows updated for vendor '{vendor}'. Not found in VendorDetails.")
            except Exception as e:
                logger.error(f"Error updating ratings for '{vendor}': {e}")
        
        conn.commit()
        return updated_count
    
    except Exception as e:
        logger.error(f"Error updating price ratings: {e}")
        return 0
    finally:
        conn.close()

def clean_data_for_supabase(value, column_name):
    """Clean and convert data for Supabase compatibility."""
    # Handle NULL values
    if value is None:
        return None
    
    # Basic type conversions
    if column_name in ('id', 'vendor_id', 'years_in_business', 'test_rating'):
        # Integer fields
        if value == "" or value == "N/A":
            return None
        try:
            return int(value)
        except (ValueError, TypeError):
            return None
            
    elif column_name in ('small_order_rating', 'large_order_rating', 'ai_rating_number'):
        # Float fields
        if value == "" or value == "N/A":
            return None
        try:
            return float(value)
        except (ValueError, TypeError):
            return None
            
    elif column_name == 'latest_batch_test_date':
        # Date/timestamp field
        if value == "" or value == "N/A":
            return None
        try:
            if isinstance(value, str):
                date_obj = datetime.strptime(value, "%Y-%m-%d %H:%M:%S")
                return date_obj.isoformat()
            return value
        except (ValueError, TypeError):
            return None
            
    elif column_name in ('refund', 'in_supabase'):
        # Boolean fields
        if isinstance(value, str):
            return value.lower() in ('true', 't', 'yes', 'y', '1')
        return bool(value)
        
    # Default: return as is
    return value

def sync_to_supabase():
    """Push updated vendor details to Supabase with proper data type handling."""
    if not SUPABASE_URL or not SUPABASE_KEY:
        logger.error("Supabase credentials not set")
        return 0
    
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    try:
        # Initialize Supabase client
        supabase = create_client(SUPABASE_URL, SUPABASE_KEY)
        
        # Get Supabase schema for column compatibility
        supabase_columns = get_supabase_schema()
        
        # First, get existing vendors from Supabase to get their IDs
        try:
            existing_response = supabase.table('vendordetails').select('id,name').execute()
            existing_supabase_vendors = {vendor['name']: vendor['id'] for vendor in existing_response.data}
            logger.info(f"Found {len(existing_supabase_vendors)} existing vendors in Supabase")
        except Exception as e:
            logger.error(f"Error fetching existing vendors from Supabase: {e}")
            existing_supabase_vendors = {}
        
        # Get all vendor details
        cursor.execute("SELECT * FROM VendorDetails")
        vendor_details = [dict(row) for row in cursor.fetchall()]
        logger.info(f"Found {len(vendor_details)} vendor details to sync")
        
        # Get vendor names if needed
        cursor.execute("SELECT id, name FROM Vendors")
        vendor_names = {row['id']: row['name'] for row in cursor.fetchall()}
        
        uploaded_count = 0
        for vendor in vendor_details:
            # Ensure name is set
            if not vendor.get('name') and 'vendor_id' in vendor and vendor['vendor_id'] in vendor_names:
                vendor['name'] = vendor_names[vendor['vendor_id']]
            
            # Skip if still no name
            if not vendor.get('name'):
                logger.warning(f"Skipping vendor ID {vendor.get('id')} with no name")
                continue
            
            vendor_name = vendor.get('name')
                
            # Convert column names and clean data
            clean_vendor_data = {}
            for k, v in vendor.items():
                # Skip system columns
                if k.lower() in ('tableoid', 'cmax', 'xmax', 'cmin', 'xmin', 'ctid'):
                    continue
                
                # Map column names to Supabase format
                mapped_key = COLUMN_MAPPING.get(k, k.lower())
                
                # Skip columns not in Supabase schema
                if mapped_key not in supabase_columns and mapped_key.lower() not in supabase_columns:
                    continue
                
                # Clean and convert data
                clean_vendor_data[mapped_key] = clean_data_for_supabase(v, mapped_key)
            
            # If vendor exists in Supabase, use its ID to ensure update works
            if vendor_name in existing_supabase_vendors:
                # Ensure we're using the Supabase ID for the update
                supabase_id = existing_supabase_vendors[vendor_name]
                if 'id' in clean_vendor_data and clean_vendor_data['id'] != supabase_id:
                    logger.info(f"Updating vendor '{vendor_name}' using existing Supabase ID: {supabase_id}")
                clean_vendor_data['id'] = supabase_id
                
                try:
                    # Use PATCH for update to avoid duplicate key errors
                    response = supabase.table('vendordetails').update(clean_vendor_data).eq('id', supabase_id).execute()
                    
                    if getattr(response, 'error', None):
                        logger.error(f"Error updating vendor {vendor_name}: {response.error}")
                    else:
                        uploaded_count += 1
                        logger.info(f"Successfully updated vendor '{vendor_name}' in Supabase")
                        
                        # Update vendors table to mark as synced
                        if 'vendor_id' in clean_vendor_data and clean_vendor_data['vendor_id']:
                            cursor.execute("UPDATE Vendors SET in_supabase = 1 WHERE id = ?", 
                                        (clean_vendor_data['vendor_id'],))
                except Exception as e:
                    logger.error(f"Error updating vendor '{vendor_name}': {e}")
            
            else:
                # If vendor doesn't exist in Supabase, insert it
                try:
                    response = supabase.table('vendordetails').insert(clean_vendor_data).execute()
                    
                    if getattr(response, 'error', None):
                        logger.error(f"Error inserting new vendor '{vendor_name}': {response.error}")
                    else:
                        uploaded_count += 1
                        logger.info(f"Successfully inserted new vendor '{vendor_name}' to Supabase")
                        
                        # Update vendors table to mark as synced
                        if 'vendor_id' in clean_vendor_data and clean_vendor_data['vendor_id']:
                            cursor.execute("UPDATE Vendors SET in_supabase = 1 WHERE id = ?", 
                                        (clean_vendor_data['vendor_id'],))
                except Exception as e:
                    logger.error(f"Error inserting vendor '{vendor_name}': {e}")
        
        conn.commit()
        return uploaded_count
    
    except Exception as e:
        logger.error(f"Error syncing to Supabase: {e}")
        return 0
    finally:
        conn.close()

def main():
    """Run the vendor management process."""
    logger.info("Starting vendor management...")
    
    # Step 1: Add new vendors to VendorDetails using name for deduplication
    try:
        new_vendors = sync_new_vendors()
        logger.info(f"Added {new_vendors} new vendors to VendorDetails")
    except Exception as e:
        logger.error(f"Error adding new vendors: {e}")
    
    # Step 2: Update price ratings
    try:
        updated_ratings = update_price_ratings()
        logger.info(f"Updated price ratings for {updated_ratings} vendors")
    except Exception as e:
        logger.error(f"Error updating price ratings: {e}")
    
    # Step 3: Sync to Supabase with proper data handling
    try:
        if SUPABASE_URL and SUPABASE_KEY:
            upserted = sync_to_supabase()
            logger.info(f"Synced {upserted} vendors to Supabase")
        else:
            logger.error("Supabase credentials missing")
    except Exception as e:
        logger.error(f"Error syncing to Supabase: {e}")
    
    logger.info("Vendor management completed")

if __name__ == "__main__":
    main()