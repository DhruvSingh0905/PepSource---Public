#!/usr/bin/env python3
import json
import sqlite3
import os
import re
from dotenv import load_dotenv
from supabase import create_client

def parse_drug_definitions(file_path):
    """
    Parse the drug definitions JSONL file and extract what_it_does and how_it_works fields.
    Returns a dictionary of drug_ids mapping to their definitions.
    """
    drug_definitions = {}
    processed_lines = 0
    successful_extractions = 0
    
    with open(file_path, 'r') as file:
        for line_num, line in enumerate(file, 1):
            processed_lines += 1
            
            try:
                # Parse the JSON line
                record = json.loads(line.strip())
                
                # Extract the custom_id which should contain the drug_id
                custom_id = record.get('custom_id', '')
                drug_id_match = re.search(r'drug(\d+)', custom_id)
                
                if not drug_id_match:
                    print(f"Line {line_num}: Could not extract drug_id from custom_id: {custom_id}")
                    continue
                
                drug_id = drug_id_match.group(1)
                
                # Check if response contains an error
                if record.get('error'):
                    print(f"Line {line_num}: API error for drug_id {drug_id}: {record['error']}")
                    continue
                
                # Extract the content from the response
                try:
                    # Navigate the response structure safely
                    if 'response' not in record or 'body' not in record['response']:
                        print(f"Line {line_num}: Missing expected response structure for drug_id {drug_id}")
                        continue
                        
                    body = record['response']['body']
                    
                    # Handle different response structures
                    if 'choices' in body and len(body['choices']) > 0:
                        if 'message' in body['choices'][0] and 'content' in body['choices'][0]['message']:
                            content = body['choices'][0]['message']['content']
                        else:
                            print(f"Line {line_num}: Missing message/content in choices for drug_id {drug_id}")
                            continue
                    else:
                        print(f"Line {line_num}: No choices found in response for drug_id {drug_id}")
                        continue
                    
                    # Extract JSON content from markdown code block or directly
                    definitions = None
                    
                    # Try to extract from markdown code block
                    json_pattern = re.search(r'```(?:json)?\s*\n(.*?)\n```', content, re.DOTALL)
                    if json_pattern:
                        try:
                            definitions = json.loads(json_pattern.group(1))
                        except json.JSONDecodeError:
                            # Try cleaning the string and retrying
                            clean_json = json_pattern.group(1).strip()
                            try:
                                definitions = json.loads(clean_json)
                            except json.JSONDecodeError:
                                pass
                    
                    # If that didn't work, try parsing the whole content as JSON
                    if not definitions:
                        try:
                            definitions = json.loads(content)
                        except json.JSONDecodeError:
                            pass
                    
                    # If that didn't work, try finding JSON object with regex
                    if not definitions:
                        json_pattern = re.search(r'\{.*\}', content, re.DOTALL)
                        if json_pattern:
                            try:
                                definitions = json.loads(json_pattern.group(0))
                            except json.JSONDecodeError:
                                pass
                    
                    # Store extracted definitions if they contain the expected fields
                    if definitions and isinstance(definitions, dict):
                        what_it_does = definitions.get('what_it_does')
                        how_it_works = definitions.get('how_it_works')
                        
                        if what_it_does or how_it_works:
                            drug_definitions[drug_id] = {
                                'what_it_does': what_it_does,
                                'how_it_works': how_it_works
                            }
                            successful_extractions += 1
                        else:
                            print(f"Line {line_num}: Missing expected fields in definitions for drug_id {drug_id}")
                    else:
                        print(f"Line {line_num}: Could not extract valid definitions for drug_id {drug_id}")
                
                except (KeyError, json.JSONDecodeError, AttributeError) as e:
                    print(f"Line {line_num}: Error extracting definitions for drug_id {drug_id}: {e}")
                    continue
                    
            except json.JSONDecodeError as e:
                print(f"Line {line_num}: Error parsing JSON line: {e}")
                continue
    
    print(f"Processed {processed_lines} lines, successfully extracted definitions for {successful_extractions} drugs")
    return drug_definitions

def update_local_database(db_path, drug_definitions):
    """
    Update the SQLite database with drug definitions.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    updates_made = 0
    
    try:
        for drug_id, definitions in drug_definitions.items():
            # Begin a transaction for each drug's update
            cursor.execute("BEGIN TRANSACTION")
            
            try:
                # Update the drug record with definitions
                cursor.execute(
                    """
                    UPDATE Drugs 
                    SET what_it_does = ?, how_it_works = ?, in_supabase = FALSE
                    WHERE id = ?
                    """,
                    (definitions.get('what_it_does'), definitions.get('how_it_works'), drug_id)
                )
                
                if cursor.rowcount > 0:
                    updates_made += 1
                else:
                    print(f"No drug found with ID {drug_id}")
                
                # Commit transaction for this drug
                conn.commit()
                
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error updating drug ID {drug_id}: {e}")
        
    except Exception as e:
        conn.rollback()
        print(f"Transaction rolled back due to error: {e}")
    finally:
        conn.close()
    
    print(f"Updated {updates_made} drugs in the local database")
    return updates_made

def upsert_to_supabase(db_path):
    """
    Upsert updated drug definitions to Supabase.
    """
    # Load environment variables from .env file
    load_dotenv()
    
    # Get Supabase credentials
    SUPABASE_URL = os.getenv("VITE_SUPABASE_URL")
    SUPABASE_SERVICE_KEY = os.getenv("VITE_SUPABASE_SERVICE_KEY")
    
    if not SUPABASE_URL or not SUPABASE_SERVICE_KEY:
        print("Error: Supabase credentials are not set in environment variables.")
        return
    
    # Connect to Supabase
    try:
        supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)
    except Exception as e:
        print(f"Error connecting to Supabase: {e}")
        return
    
    # Connect to SQLite database
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    try:
        # Fetch drugs that need to be upserted to Supabase
        cursor.execute("SELECT * FROM Drugs WHERE in_supabase = FALSE OR in_supabase = 0")
        drugs = cursor.fetchall()
        
        if not drugs:
            print("No drugs to upsert to Supabase.")
            return
        
        # Prepare rows for Supabase
        supabase_drugs = []
        for row in drugs:
            drug_dict = dict(row)
            drug_dict["in_supabase"] = True
            supabase_drugs.append(drug_dict)
        
        # Upsert to Supabase
        print(f"Upserting {len(supabase_drugs)} drugs to Supabase...")
        response = supabase.table("drugs").upsert(supabase_drugs, on_conflict="id").execute()
        
        # Mark drugs as in Supabase
        cursor.execute("UPDATE Drugs SET in_supabase = TRUE WHERE in_supabase = FALSE OR in_supabase = 0")
        conn.commit()
        
        print(f"Successfully upserted {len(supabase_drugs)} drugs to Supabase")
        
    except Exception as e:
        print(f"Error upserting drugs to Supabase: {e}")
        conn.rollback()
    finally:
        conn.close()

def main():
    # File paths
    jsonl_file = "DB/Batch_requests/drug_definitions_rewrite_results.jsonl"
    db_file = "DB/pepsources.db"
    
    # Check if files exist
    if not os.path.exists(jsonl_file):
        print(f"Error: JSONL file not found at {jsonl_file}")
        return
    
    if not os.path.exists(db_file):
        print(f"Error: Database file not found at {db_file}")
        return
    
    # Parse the JSONL file
    print(f"Parsing drug definitions from {jsonl_file}...")
    drug_definitions = parse_drug_definitions(jsonl_file)
    
    # Print some stats
    drug_count = len(drug_definitions)
    print(f"Found definitions for {drug_count} drugs")
    
    # Update the local database
    print(f"Updating local database at {db_file}...")
    update_local_database(db_file, drug_definitions)
    
    # Upsert to Supabase
    print("Upserting updated drugs to Supabase...")
    upsert_to_supabase(db_file)
    
    print("All operations completed successfully!")

if __name__ == "__main__":
    main()