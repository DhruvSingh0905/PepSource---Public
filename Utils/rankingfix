#!/usr/bin/env python3
import json
import sqlite3
import os
import re
import logging
from dotenv import load_dotenv
from supabase import create_client

def parse_jsonl_file(file_path):
    """
    Parse a JSONL file containing batch request outputs and extract article rankings.
    Returns a dictionary of drug_ids mapping to article rankings.
    Enhanced with better error handling for various response formats.
    """
    all_rankings = {}
    processed_lines = 0
    successful_extractions = 0
    
    with open(file_path, 'r') as file:
        for line_num, line in enumerate(file, 1):
            processed_lines += 1
            
            try:
                # Parse the JSON line
                record = json.loads(line.strip())
                
                # Extract the custom_id which should contain the drug_id
                custom_id = record.get('custom_id', '')
                drug_id_match = re.search(r'drug(\d+)_order', custom_id)
                
                if not drug_id_match:
                    print(f"Line {line_num}: Could not extract drug_id from custom_id: {custom_id}")
                    continue
                
                drug_id = drug_id_match.group(1)
                
                # Check if response contains an error
                if record.get('error'):
                    print(f"Line {line_num}: API error for drug_id {drug_id}: {record['error']}")
                    continue
                
                # Extract the content from the response
                try:
                    # Navigate the response structure safely
                    if 'response' not in record or 'body' not in record['response']:
                        print(f"Line {line_num}: Missing expected response structure for drug_id {drug_id}")
                        continue
                        
                    body = record['response']['body']
                    
                    # Handle different response structures
                    if 'choices' in body and len(body['choices']) > 0:
                        if 'message' in body['choices'][0] and 'content' in body['choices'][0]['message']:
                            content = body['choices'][0]['message']['content']
                        else:
                            print(f"Line {line_num}: Missing message/content in choices for drug_id {drug_id}")
                            continue
                    else:
                        print(f"Line {line_num}: No choices found in response for drug_id {drug_id}")
                        continue
                    
                    # Try different patterns to extract JSON
                    rankings = None
                    
                    # Pattern 1: Markdown JSON block
                    json_pattern = re.search(r'```(?:json)?\s*\n(.*?)\n```', content, re.DOTALL)
                    if json_pattern:
                        try:
                            rankings = json.loads(json_pattern.group(1))
                        except json.JSONDecodeError:
                            # Try cleaning the string and retrying
                            clean_json = json_pattern.group(1).strip().replace('\n', '')
                            try:
                                rankings = json.loads(clean_json)
                            except json.JSONDecodeError:
                                pass
                    
                    # Pattern 2: Direct JSON
                    if not rankings:
                        try:
                            rankings = json.loads(content)
                        except json.JSONDecodeError:
                            pass
                    
                    # Pattern 3: JSON with surrounding text
                    if not rankings:
                        json_pattern = re.search(r'\{.*\}', content, re.DOTALL)
                        if json_pattern:
                            try:
                                rankings = json.loads(json_pattern.group(0))
                            except json.JSONDecodeError:
                                pass
                    
                    if rankings and isinstance(rankings, dict):
                        all_rankings[drug_id] = rankings
                        successful_extractions += 1
                    else:
                        print(f"Line {line_num}: Could not extract valid rankings for drug_id {drug_id}")
                
                except (KeyError, json.JSONDecodeError, AttributeError) as e:
                    print(f"Line {line_num}: Error extracting rankings for drug_id {drug_id}: {e}")
                    continue
                    
            except json.JSONDecodeError as e:
                print(f"Line {line_num}: Error parsing JSON line: {e}")
                continue
    
    print(f"Processed {processed_lines} lines, successfully extracted rankings for {successful_extractions} drugs")
    return all_rankings

def update_database(db_path, rankings_by_drug):
    """
    Update the SQLite database with article rankings for each drug.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Get total updates to report
    total_updates = sum(len(rankings) for rankings in rankings_by_drug.values())
    updates_made = 0
    
    try:
        for drug_id, article_rankings in rankings_by_drug.items():
            # Begin a transaction for each drug's updates
            cursor.execute("BEGIN TRANSACTION")
            
            for article_id, rank in article_rankings.items():
                try:
                    # Update the order_num for the article with the specified drug_id
                    cursor.execute(
                        "UPDATE articles SET order_num = ? WHERE id = ? AND drug_id = ?",
                        (rank, article_id, drug_id)
                    )
                    
                    # If no rows were updated and drug_id might be NULL or different format
                    if cursor.rowcount == 0:
                        cursor.execute(
                            "UPDATE articles SET order_num = ? WHERE id = ?",
                            (rank, article_id)
                        )
                    
                    updates_made += cursor.rowcount
                    
                except sqlite3.Error as e:
                    print(f"Error updating article ID {article_id} for drug {drug_id}: {e}")
            
            # Commit transaction for this drug
            conn.commit()
            print(f"Updated rankings for drug ID {drug_id}")
    
    except Exception as e:
        conn.rollback()
        print(f"Transaction rolled back due to error: {e}")
    finally:
        conn.close()
    
    print(f"Completed updates: {updates_made} of {total_updates} expected updates")

def upsert_to_supabase(db_file):
    """
    Upsert updated article rankings to Supabase, ensuring data consistency.
    Skips articles with non-existent drug IDs in the drugs table.
    """
    # Load environment variables from .env file
    load_dotenv()
    
    # Get Supabase credentials
    SUPABASE_URL = os.getenv("VITE_SUPABASE_URL")
    SUPABASE_SERVICE_KEY = os.getenv("VITE_SUPABASE_SERVICE_KEY")
    
    if not SUPABASE_URL or not SUPABASE_SERVICE_KEY:
        print("Error: Supabase credentials are not set in environment variables.")
        return
    
    # Connect to Supabase
    try:
        supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)
    except Exception as e:
        print(f"Error connecting to Supabase: {e}")
        return
    
    # Connect to SQLite database
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    try:
        # Mark articles as not in Supabase if order_num has been updated
        cursor.execute("""
            UPDATE articles 
            SET in_supabase = FALSE 
            WHERE order_num IS NOT NULL
        """)
        conn.commit()
        
        # Fetch articles that need to be upserted
        cursor.execute("SELECT * FROM articles WHERE in_supabase = FALSE OR in_supabase = 0")
        articles = cursor.fetchall()
        
        if not articles:
            print("No articles to upsert to Supabase.")
            return
            
        # First, get a list of all valid drug IDs from Supabase
        try:
            drug_response = supabase.table("drugs").select("id").execute()
            valid_drug_ids = [str(drug['id']) for drug in drug_response.data]
            print(f"Found {len(valid_drug_ids)} valid drug IDs in Supabase")
        except Exception as e:
            print(f"Error fetching drug IDs from Supabase: {e}")
            valid_drug_ids = []
        
        # Prepare rows for Supabase, filtering out articles with invalid drug_ids
        supabase_articles = []
        skipped_articles = []
        
        for row in articles:
            article_dict = dict(row)
            
            # Check if drug_id exists in the drugs table
            if article_dict.get('drug_id') and str(article_dict['drug_id']) not in valid_drug_ids:
                skipped_articles.append(article_dict['id'])
                # Delete articles with non-existent drug IDs as requested
                cursor.execute("DELETE FROM articles WHERE id = ?", (article_dict['id'],))
                continue
                
            article_dict["in_supabase"] = True
            supabase_articles.append(article_dict)
        
        conn.commit()
        
        if skipped_articles:
            print(f"Deleted {len(skipped_articles)} articles with non-existent drug IDs: {skipped_articles[:10]}{'...' if len(skipped_articles) > 10 else ''}")
            
        if not supabase_articles:
            print("No valid articles to upsert to Supabase after filtering.")
            return
        
        # Upsert valid articles to Supabase
        print(f"Upserting {len(supabase_articles)} articles to Supabase...")
        
        # Process in batches to avoid potential payload size limits
        batch_size = 100
        for i in range(0, len(supabase_articles), batch_size):
            batch = supabase_articles[i:i+batch_size]
            try:
                response = supabase.table("articles").upsert(batch, on_conflict="id").execute()
                print(f"Successfully upserted batch {i//batch_size + 1}/{(len(supabase_articles)-1)//batch_size + 1} ({len(batch)} articles)")
            except Exception as e:
                print(f"Error upserting batch {i//batch_size + 1}: {e}")
        
        # Mark remaining articles as in Supabase
        cursor.execute("UPDATE articles SET in_supabase = TRUE WHERE in_supabase = FALSE OR in_supabase = 0")
        conn.commit()
        
        print(f"Upsert operation complete. {len(supabase_articles)} articles processed.")
        
    except Exception as e:
        print(f"Error in Supabase upsert process: {e}")
        conn.rollback()
    finally:
        conn.close()

def main():
    # File paths
    jsonl_file = "DB/Batch_requests/batch_output_order_articles.jsonl"
    db_file = "DB/pepsources.db"  # Update this to your actual database path
    
    # Check if files exist
    if not os.path.exists(jsonl_file):
        print(f"Error: JSONL file not found at {jsonl_file}")
        return
    
    if not os.path.exists(db_file):
        print(f"Error: Database file not found at {db_file}")
        return
    
    # Parse the JSONL file
    print(f"Parsing rankings from {jsonl_file}...")
    rankings_by_drug = parse_jsonl_file(jsonl_file)
    
    # Print some stats
    drug_count = len(rankings_by_drug)
    article_count = sum(len(rankings) for rankings in rankings_by_drug.values())
    print(f"Found rankings for {drug_count} drugs and {article_count} articles")
    
    # Update the database
    print(f"Updating database at {db_file}...")
    update_database(db_file, rankings_by_drug)
    
    # Upsert to Supabase
    print("Upserting updated articles to Supabase...")
    upsert_to_supabase(db_file)
    
    print("All operations completed successfully!")

if __name__ == "__main__":
    main()